package com.generalidevelopment.hit2013.util;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import com.generalidevelopment.hit2013.util.error.ErrorHandler;
import com.generalidevelopment.hit2013.util.json.JSONMessage;
import com.generalidevelopment.hit2013.util.json.JSONMessageFormat;
import com.generalidevelopment.hit2013.util.json.JSONMessageType;
import com.generalidevelopment.hit2013.util.json.JSONResponseEnvelope;
import com.generalidevelopment.hit2013.util.json.JSONResponseStatus;
import com.generalidevelopment.hit2013.util.json.JsonErrorObjectFactory;

/**
 * Handler class used for handling Ajax and standard requests to the application. Class is needed to be added to
 * application context. Response to Ajax is generated by private <DefaultJsonErrorObjectFactory> but can be overriden by
 * class which implements <JsonErrorObjectFactory> interface.
 * 
 */
public class AjaxHandlerExceptionResolver extends AbstractHandlerExceptionResolver implements MessageSourceAware {

	private static final int AJAX_HANDLER_EXCEPTION_RESOLVER_ORDER = -10;

	protected final Log logger = LogFactory.getLog(getClass());

	private JsonErrorObjectFactory jsonErrorObjectFactory = new DefaultJsonErrorObjectFactory();
	private final List<HttpMessageConverter<?>> messageConverters;
	private ErrorHandler errorHandler;

	private MessageSource messageSource;

	public AjaxHandlerExceptionResolver() {

		this.messageConverters = new ArrayList<HttpMessageConverter<?>>();
		this.messageConverters.add(new MappingJacksonHttpMessageConverter());

		setOrder(AJAX_HANDLER_EXCEPTION_RESOLVER_ORDER);
	}

	@Override
	protected boolean shouldApplyTo(final HttpServletRequest request, final Object handler) {
		return super.shouldApplyTo(request, handler) && isAjaxRequest(request);
	}

	@Override
	protected ModelAndView doResolveException(final HttpServletRequest request, final HttpServletResponse response,
			final Object handler, final Exception ex) {

		final ServletWebRequest webRequest = new ServletWebRequest(request, response);
		final ModelAndViewContainer mavContainer = new ModelAndViewContainer();

		final Object ajaxResponse = jsonErrorObjectFactory.create(ex);
		final HandlerMethodReturnValueHandler returnValueHandler = new RequestResponseBodyMethodProcessor(
				messageConverters);
		try {
			if (errorHandler != null) {
				errorHandler.handleException(ex);
			} else {
				logger.warn("No error handler set, do nothing.");
			}
			returnValueHandler.handleReturnValue(ajaxResponse, null, mavContainer, webRequest);
			if (!mavContainer.isRequestHandled()) {
				throw new RuntimeException("Error in AjaxHandlerExceptionHandler.");
			}
			return new ModelAndView();
		} catch (final Exception e) {

			throw new RuntimeException("Error in AjaxHandlerExceptionHandler.", e);
		}
	}

	private class DefaultJsonErrorObjectFactory implements JsonErrorObjectFactory {

		@Override
		public Object create(final Exception ex) {
			final JSONResponseEnvelope response = new JSONResponseEnvelope();
			response.setResponseStatus(JSONResponseStatus.ERROR);
			response.setStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			JSONMessage message;
			// get message from message code and display it to the user
			final Locale locale = LocaleContextHolder.getLocale();

			// final DcsBusinessExceptionWrapper rejectedException = new DcsBusinessExceptionWrapper(ex);
			// final String resolvedMessage = messageSource.getMessage(rejectedException.getCode(),
			// rejectedException.getArguments(), locale);
			message = new JSONMessage(1, JSONMessageType.ERROR, ex.getClass().toString(), JSONMessageFormat.TEXT,
					ex.getMessage(), ex.getMessage());

			response.getMessages().add(message);
			return response;
		}

	}

	// Not sure if this method is implemented properly
	@SuppressWarnings("unchecked")
	protected boolean isAjaxRequest(final HttpServletRequest request) {
		final Set<MediaType> mediaTypes = (Set<MediaType>) request
				.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
		return mediaTypes != null && mediaTypes.contains(MediaType.APPLICATION_JSON);
	}

	public ErrorHandler getErrorHandler() {
		return errorHandler;
	}

	public void setErrorHandler(final ErrorHandler errorHandler) {
		this.errorHandler = errorHandler;
	}

	public JsonErrorObjectFactory getJsonErrorObjectFactory() {
		return jsonErrorObjectFactory;
	}

	public void setJsonErrorObjectFactory(final JsonErrorObjectFactory jsonErrorObjectFactory) {
		this.jsonErrorObjectFactory = jsonErrorObjectFactory;
	}

	@Override
	public void setMessageSource(final MessageSource messageSource) {
		this.messageSource = messageSource;

	}

}
